<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>P4P: A Syntax Proposal</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" /><script type="text/javascript" src="scribble-common.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" pltdoc="x">P4P:<span class="mywbr"> </span> A Syntax Proposal</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#(part._.A_.Thought_.Experiment)" class="tocviewlink" pltdoc="x">A Thought Experiment</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#(part._.Examples)" class="tocviewlink" pltdoc="x">Examples</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#(part._.The_.Central_.Idea)" class="tocviewlink" pltdoc="x">The Central Idea</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#(part._.Design)" class="tocviewlink" pltdoc="x">Design</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#(part._.Indentation___.Rules_)" class="tocviewlink" pltdoc="x">Indentation...Rules!</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#(part._.On_.Groves_and_.Brooks__or__.Trees_and_.Streams_)" class="tocviewlink" pltdoc="x">On Groves and Brooks (or, Trees and Streams)</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#(part._.Error_.Reporting)" class="tocviewlink" pltdoc="x">Error Reporting</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="#(part._.Syntax_.Extensions)" class="tocviewlink" pltdoc="x">Syntax Extensions</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="#(part._.Conclusion)" class="tocviewlink" pltdoc="x">Conclusion</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#(part._.A_.Thought_.Experiment)" class="tocsubseclink" pltdoc="x">A Thought Experiment</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#(part._.Examples)" class="tocsubseclink" pltdoc="x">Examples</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#(part._.The_.Central_.Idea)" class="tocsubseclink" pltdoc="x">The Central Idea</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#(part._.Design)" class="tocsubseclink" pltdoc="x">Design</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#(part._.Decisions)" class="tocsubseclink" pltdoc="x">Decisions</a></td></tr><tr><td><span class="tocsublinknumber">4.1.1<tt>&nbsp;</tt></span><a href="#(part._.Embracing_.Prefix)" class="tocsubseclink" pltdoc="x">Embracing Prefix</a></td></tr><tr><td><span class="tocsublinknumber">4.1.2<tt>&nbsp;</tt></span><a href="#(part._.Adopting_.Racket_s_.Token_.Syntax)" class="tocsubseclink" pltdoc="x">Adopting Racket&rsquo;s Token Syntax</a></td></tr><tr><td><span class="tocsublinknumber">4.1.3<tt>&nbsp;</tt></span><a href="#(part._.Keeping_.Parsing_.Predictable)" class="tocsubseclink" pltdoc="x">Keeping Parsing Predictable</a></td></tr><tr><td><span class="tocsublinknumber">4.1.4<tt>&nbsp;</tt></span><a href="#(part._.Leaving_the_.Semantics_.Untouched)" class="tocsubseclink" pltdoc="x">Leaving the Semantics Untouched</a></td></tr><tr><td><span class="tocsublinknumber">4.1.5<tt>&nbsp;</tt></span><a href="#(part._.Attaining_.Arity_.Clarity)" class="tocsubseclink" pltdoc="x">Attaining Arity Clarity</a></td></tr><tr><td><span class="tocsublinknumber">4.1.6<tt>&nbsp;</tt></span><a href="#(part._.Adopting_.Indentation_.Without_.Semantics)" class="tocsubseclink" pltdoc="x">Adopting Indentation Without Semantics</a></td></tr><tr><td><span class="tocsublinknumber">4.1.7<tt>&nbsp;</tt></span><a href="#(part._.Reusing_the_.Tool_.Chain)" class="tocsubseclink" pltdoc="x">Reusing the Tool Chain</a></td></tr><tr><td><span class="tocsublinknumber">4.1.8<tt>&nbsp;</tt></span><a href="#(part._.Avoiding_.Optional_.Syntax)" class="tocsubseclink" pltdoc="x">Avoiding Optional Syntax</a></td></tr><tr><td><span class="tocsublinknumber">4.1.9<tt>&nbsp;</tt></span><a href="#(part._.Avoiding_.New_.Spacing_.Conventions)" class="tocsubseclink" pltdoc="x">Avoiding New Spacing Conventions</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#(part._.Choices)" class="tocsubseclink" pltdoc="x">Choices</a></td></tr><tr><td><span class="tocsublinknumber">4.2.1<tt>&nbsp;</tt></span><a href="#(part._.Distinguishing_.Keywords)" class="tocsubseclink" pltdoc="x">Distinguishing Keywords</a></td></tr><tr><td><span class="tocsublinknumber">4.2.2<tt>&nbsp;</tt></span><a href="#(part._.Using_.Syntactic_.Embellishments)" class="tocsubseclink" pltdoc="x">Using Syntactic Embellishments</a></td></tr><tr><td><span class="tocsublinknumber">4.2.3<tt>&nbsp;</tt></span><a href="#(part._.Handling_.Variterm_.Constructs)" class="tocsubseclink" pltdoc="x">Handling Variterm Constructs</a></td></tr><tr><td><span class="tocsublinknumber">4.2.4<tt>&nbsp;</tt></span><a href="#(part._.Avoiding_.Closing_.Delimiters)" class="tocsubseclink" pltdoc="x">Avoiding Closing Delimiters</a></td></tr><tr><td><span class="tocsublinknumber">4.2.5<tt>&nbsp;</tt></span><a href="#(part._.Not_.Specifying_the_.Indentation_of_.Parenthetical_.Pairs)" class="tocsubseclink" pltdoc="x">Not Specifying the Indentation of Parenthetical Pairs</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#(part._.Indentation___.Rules_)" class="tocsubseclink" pltdoc="x">Indentation...Rules!</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#(part._.On_.Groves_and_.Brooks__or__.Trees_and_.Streams_)" class="tocsubseclink" pltdoc="x">On Groves and Brooks (or, Trees and Streams)</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#(part._.Error_.Reporting)" class="tocsubseclink" pltdoc="x">Error Reporting</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#(part._.Syntax_.Extensions)" class="tocsubseclink" pltdoc="x">Syntax Extensions</a></td></tr><tr><td><span class="tocsublinknumber">9<tt>&nbsp;</tt></span><a href="#(part._.Conclusion)" class="tocsubseclink" pltdoc="x">Conclusion</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.P4.P__.A_.Syntax_.Proposal)"></a>P4P: A Syntax Proposal</h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Shriram Krishnamurthi</p></span></div><p>This document proposes an alternate syntax for Racket.  It reduces the parenthetical burden, makes the language appear more traditional, and respects indentation, though not in the way you think.  It does all this while retaining the essence of Racket syntax, and even offering a high degree of tool reuse.</p><h3>1<tt>&nbsp;</tt><a name="(part._.A_.Thought_.Experiment)"></a>A Thought Experiment</h3><p><div class="SIntrapara">Consider the following Racket function definition:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define (square x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(* x x))</span></span></p></td></tr></table></div><div class="SIntrapara">Imagine you were asked to consider reducing the number of parentheses in Scheme.  Well, we certainly can&rsquo;t remove the parentheses around the multiplication, because it has variable arity; nor those around the function header, since we wouldn&rsquo;t be able to tell whether <span class="stt">*</span> is an argument or not.  But it would appear <span class="stt">define</span> contains all the information we need; that is, we could write
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">define (square x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(* x x)</span></span></p></td></tr></table></div></p><p><div class="SIntrapara">Except, of course, that this has now made our language ambiguous.  If instead we were to write
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">define (square x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(* x x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;</span><span class="stt">(+ x x)</span></span></p></td></tr></table></div><div class="SIntrapara">what do we mean?  Is the addition expression a second body in the definition of <span class="stt">square</span>, or is it a separate top-level expression (with <span class="stt">x</span> unbound)?</div></p><p><div class="SIntrapara">Aha, you might think: &ldquo;Didn&rsquo;t he say <span style="font-style: italic">indentation</span> earlier?&rdquo;  And indeed, that would help us distinguish
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">define (square x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(* x x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(+ x x)</span></span></p></td></tr></table></div><div class="SIntrapara">from
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">define (square x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(* x x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(+ x x)</span></span></p></td></tr></table></div><div class="SIntrapara">and decide the earlier option (where <span class="stt">(+ x x)</span> had uncertain indentation) was ambiguous and hence erroneous.</div></p><p>Except that&rsquo;s not what we&rsquo;re going to do.  Read on.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Examples)"></a>Examples</h3><p>Before we dive into details, let&rsquo;s see some running P4P programs.  I intentionally show only code, not output.  If there is any doubt as to what these programs mean (and you aren&rsquo;t just trying to be ornery), P4P has failed.</p><p><div class="SIntrapara">First, a few variable and function definitions:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">defvar: m = 10</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">defvar: this-better-be-6 = add(1, 2, 3)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">defvar: this-better-be-0 = add()</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: five() = 5</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: trpl(x) = add(x, x, x)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: g(a, b, c) = add(a, b, c)</span></span></p></td></tr></table></div><div class="SIntrapara">Commas &ndash; yes, commas! We&rsquo;ll have more to say about them below.</div></p><p><div class="SIntrapara">Anonymous functions:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: d/dx(f) =</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">defvar: delta = 0.001</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun: (x) in:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">div(sub(f(add(x, delta)),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">f(x)),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">delta)</span></span></p></td></tr></table></div><div class="SIntrapara">Conditionals:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: fib(n) =</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if: numeq(n, 0)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">elif: numeq(n, 1)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">else:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">add(fib(sub1(n)), fib(sub(n, 2)))</span></span></p></td></tr></table></div><div class="SIntrapara">Structures:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">defstruct: memo has: (key, ans)</span></span></p></td></tr></table></div><div class="SIntrapara">Sequencing (look for <span class="stt">do:</span>):
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: memoize (f) =</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">defvar: memo-table = box(empty)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fun: args in:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">defvar: lookup =</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">filter(fun: (v) in:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">equal?(args, memo-key(v)),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">unbox(memo-table))</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if: empty?(lookup)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">do: (</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">set-box!(memo-table,</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">cons (make-memo (args, apply(f, args)),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">unbox(memo-table)))</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">apply(f, args))</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">memo-ans(first(lookup))</span></span></p></td></tr></table></div><div class="SIntrapara">Expressions in function position:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">defvar: this-better-be-9 = {fun: (n) in: mult(n, n)}(3)</span></span></p></td></tr></table></div><div class="SIntrapara">Local bindings:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">let:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 3,</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">y = 2</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;</span><span class="stt">in:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">+(x, y)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">let*: x = 3, y = x in: add(x, y)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">letrec: even = fun: (n) in: if: zero?(n) true else: odd?(sub1(n)),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">odd = fun: (n) in:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if: zero?(n)</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">false</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">odd?(sub1(n))</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;</span><span class="stt">in: list(odd?(10), even?(10))</span></span></p></td></tr></table></div></p><h3>3<tt>&nbsp;</tt><a name="(part._.The_.Central_.Idea)"></a>The Central Idea</h3><p>P4P hinges on one central idea and its consequences.</p><p>First, the idea: let&rsquo;s get rid of implicit-<span class="stt">begin</span>-ness.  Where we need a variable number of terms, write a <span class="stt">do:</span>.  This small change suddenly eliminates the ambiguity that pervades Racket parsing and forces parentheses to clarify intent.  The odds are that the extra typing engendered by <span class="stt">do:</span> will be offset by the reduction in typing parentheses.</p><p>Once we have made the syntax unambiguous <span style="font-style: italic">without the help of parentheses</span>, we can get rid of the parentheses themselves.  That is, keywords like <span class="stt">deffun:</span> are sufficient to tell us what shape of terms to expect in legal programs.  (Of course, every language construct must follow this property &ndash; even <span class="stt">do:</span>.)</p><p><div class="SIntrapara">This results in a pleasant invariant about parenthetical structure. In Racket, Scheme, and Lisp, functions are notorious for trailing off into a saga of parentheses (which in Racket are broken up by the odd square-bracket, which sometimes makes maintenance even more painful).  In P4P, the only closing parentheses are from <span style="font-style: italic">expressions</span>, because the language&rsquo;s constructs (other than <span class="stt">do:</span> and its kin, which anyway use braces) do not contribute any.  Thus, the parenthetical depth is precisely the same as the function nesting depth.  For beginners, in particular, since this rarely exceeds 2&ndash;3, neither does the number of adjacent parentheses.  For instance, in Racket, a typical memoized Fibonacci function ends in
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(+ (memofib (sub1 n)) (memofib (- n 2)))]))))</span></span></p></td></tr></table></div><div class="SIntrapara">whereas the equivalent in P4P (using <span class="stt">if:</span>s and <span class="stt">elif:</span>s in place of Racket&rsquo;s <span class="stt">cond</span>) ends (using the same operators, though P4P also defines <span class="stt">add</span> and <span class="stt">sub</span>) in
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">+(memofib(sub1(n)), memofib(-(n, 2))))</span></span></p></td></tr></table></div><div class="SIntrapara">(The one parenthesis not accounted for on this line itself is the invocation of <span class="stt">memoize</span>.)</div></p><p><div class="SIntrapara">Those old enough to remember Pascal will know this isn&rsquo;t the whole story.  Pascal enabled programming language course instructors to ask students such world-class exam questions as the value of
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">IF false IF false THEN 2</span></span></p></td></tr></table></div><div class="SIntrapara">(taking some liberties with Pascal syntax): the question being, of course, which <span class="stt">IF</span> the <span class="stt">THEN</span> associates with.  If you&rsquo;re thinking now, finally, P4P will rely on indentation, you&rsquo;re wrong again (in the land of the one-armed <span class="stt">IF</span>, the people go blind from squinting). Rather, the P4P equivalent of this expression is simply illegal.  If you want a one-armed conditional, use <span class="stt">when:</span> or <span class="stt">unless:</span>.  Students, rejoice!</div></p><h3>4<tt>&nbsp;</tt><a name="(part._.Design)"></a>Design</h3><p>Now I present some design decisions and design choices.  Decisions are those I believe in and would change only under duress; choices are points of flexibility where I can be talked into alternatives.</p><h4>4.1<tt>&nbsp;</tt><a name="(part._.Decisions)"></a>Decisions</h4><h5>4.1.1<tt>&nbsp;</tt><a name="(part._.Embracing_.Prefix)"></a>Embracing Prefix</h5><p>We remain unabashedly prefix.  By doing so, we circumvent all decisions about precedence, binding, associativity, and so on.
Some initial grumbling may ensue when confronted with code like <span class="stt">+(1, 2)</span>, but this seems much less strange after you have seen <span class="stt">append(list1, list2)</span>.
Bootstrap anyway wants students to understand that exalted <span class="stt">+</span> is just another operation &ndash; just like lowly <span class="stt">append</span>.</p><h5>4.1.2<tt>&nbsp;</tt><a name="(part._.Adopting_.Racket_s_.Token_.Syntax)"></a>Adopting Racket&rsquo;s Token Syntax</h5><p>By not permitting infix, we are free to be generous about token names: <span class="stt">append-string</span>, <span class="stt">overlay/xy</span>, and <span class="stt">d/dx</span> are available.  However, there is no reason to preclude <span class="stt">e^&lt;i*pi&gt;-1</span>, either.  In short, we use Racket&rsquo;s token syntax, which will simplify interoperation with traditional, parenthesized Racket.</p><h5>4.1.3<tt>&nbsp;</tt><a name="(part._.Keeping_.Parsing_.Predictable)"></a>Keeping Parsing Predictable</h5><p>Despite the lack of parentheses, the parser is top-down and syntax-directed.  It has only one token of lookahead, in this one case: when given an identifier in expression position, it has to look ahead for a left-parenthesis to determine whether or not this is an application.  This is common in other languages too.  If the input stream (file, <span class="Smaller">REPL</span> interaction, etc.) ends after the identifier, P4P treats it as a variable reference.  (This ambiguity will affect tools like the kill-s-expression key-binding: if it faces an identifier, it will have to check whether the identifier is followed by an argument list.)</p><p>One potential source of ambiguity is the function position of an application being a non-identifier expression.  In such cases, the expression must be wrapped in braces.  Because the use of expressions in function positions is not common, this is a small price pay.  Note that functions passed as arguments are bound to identifiers, so they will not suffer from this burden; the problem similarly disappears if the expression were first bound to a name (which might clarify intent).</p><h5>4.1.4<tt>&nbsp;</tt><a name="(part._.Leaving_the_.Semantics_.Untouched)"></a>Leaving the Semantics Untouched</h5><p>This is <span style="font-style: italic">purely</span> about syntax.  The semantics of P4P is precisely that of Racket.  For instance, the P4P equivalent of <span class="stt">begin</span> currently allows only a sequence of expressions; if Racket began to permit definitions before expressions, so would P4P.  Even naming stays untouched: if tomorrow structure constructors were to no longer be preceded by <span class="stt">make-</span>, that would be just as true of P4P.</p><h5>4.1.5<tt>&nbsp;</tt><a name="(part._.Attaining_.Arity_.Clarity)"></a>Attaining Arity Clarity</h5><p>Function invocations are delimited.  Therefore we neither need to a-priori fix arity nor need types to tell us what the arity will be.  Despite this, we can have functions that unambiguously consume multiple arity, just as in Racket: <span class="stt">+(1, 2)</span>, <span class="stt">+(1, 2, 3)</span>, <span class="stt">+(1)</span>, and <span class="stt">+()</span> are all legal P4P expressions with the expected meanings.</p><h5>4.1.6<tt>&nbsp;</tt><a name="(part._.Adopting_.Indentation_.Without_.Semantics)"></a>Adopting Indentation Without Semantics</h5><p>I increasingly view emphasizing good indentation as critical.  In some languages, however, indentation controls semantics.  I view this as a mistake.</p><p>In P4P, instead, the semantics controls indentation: that is, each construct has indentation rules, and the parser enforces them.  However, changing the indentation of a term either leaves the program&rsquo;s meaning unchanged or results in a syntax error; it cannot change the meaning of the program.  I believe this delivers the advantages of enforced indentation while curbing its worst excesses.</p><p>There is a pleasant side-effect to this decision: the parser can be run in a mode where indentation-checking is simply turned off. (Obviously, this is meaningless to do in a language where indentation controls semantics.) This can be beneficial when dealing with program-generated code.  Thus, it preserves the Lisp tradition&rsquo;s friendliness to generated code while imposing higher standards on human programmers.</p><h5>4.1.7<tt>&nbsp;</tt><a name="(part._.Reusing_the_.Tool_.Chain)"></a>Reusing the Tool Chain</h5><p>P4P is implemented entirely using existing high-level Racket tools: it is defined entirely in terms of (a particular pattern of) <span class="stt">syntax-case</span> and some lower-level syntax-processing primitives.  It does not define a lexer or LR-parser.  I initially viewed this as a choice, but I have come to view this as a decision: this is the best way to ensure fidelity to Racket syntax.</p><h5>4.1.8<tt>&nbsp;</tt><a name="(part._.Avoiding_.Optional_.Syntax)"></a>Avoiding Optional Syntax</h5><p>P4P does not have any optional syntax.  I believe this makes it easier to teach people to program: they want clear instructions, not &ldquo;You can do this, or you can do that...you can do whatever you want!&rdquo;  (If they were ready to do whatever they wanted, they wouldn&rsquo;t be asking you.)  These trade-offs are best left to semantic and design levels, not syntax.  The only options in P4P are thus semantic choices: e.g., you can use or leave out <span class="stt">elif:</span> terms in a conditional, but that is a function of your program&rsquo;s logic, not your syntactic whimsy.</p><h5>4.1.9<tt>&nbsp;</tt><a name="(part._.Avoiding_.New_.Spacing_.Conventions)"></a>Avoiding New Spacing Conventions</h5><p>While P4P&rsquo;s spacing conventions can (and should) be understood in their own right, experienced Racket programmers can safely fall back on their knowledge of Racket syntax.  This, for instance, tells us that both <span class="stt">deffun: f(x) = x</span> and <span class="stt">deffun: f (x) = x</span> are valid (and so, even, is <span class="stt">deffun: f(x)= x</span>), but <span class="stt">deffun:f(x) = x</span> and <span class="stt">deffun: f(x)=x</span> will not have the presumed intended effect.  I do not view this as problematic: beginners (both educators and students) <span style="font-style: italic">always</span> ask about spacing conventions.  Since using spaces around tokens is safe, there is an easy rule to follow, which also enhances readability.  It would help for P4P&rsquo;s parser to be sensitive to the presence of special tokens and build in context-sensitive checks for them (e.g., if the first token after the function header is an identifier that begins with <span class="stt">=</span>, this should be caught by a special error case that admonishes the user to insert a space).</p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Choices)"></a>Choices</h4><h5>4.2.1<tt>&nbsp;</tt><a name="(part._.Distinguishing_.Keywords)"></a>Distinguishing Keywords</h5><p>P4P uses colons at the end of keywords.  I believe the principle of distinguishing keywords is beneficial: it tells the user, &ldquo;You are about to use a construct whose basic syntax, rules of indentation, and rules of evaluation may all be different from what you expect.&rdquo;  The particular choice of colon is whimsical and free to change, though it was inspired by Python&rsquo;s use of colons (which is somewhat different).  P4P does not prevent ordinary program variables from ending in <span class="stt">:</span>, though it would be silently frowning as it processed programs that took advantage of this liberty.</p><h5>4.2.2<tt>&nbsp;</tt><a name="(part._.Using_.Syntactic_.Embellishments)"></a>Using Syntactic Embellishments</h5><p><div class="SIntrapara">There are many syntactic embellishments in P4P.
</div><div class="SIntrapara"><ul><li><p><span class="stt">=</span> in <span class="stt">defvar:</span> and <span class="stt">deffun:</span> aren&rsquo;t necessary, but adding them seemed to
immensely improve readability.
In particular, they emphasize the substitution nature of these definitions.</p></li><li><p>There is no <span class="stt">=</span> in <span class="stt">fun:</span>; I chose <span class="stt">in:</span> instead.  This is because the argument list
does not equal the body, but rather is bound in it.  The choice of <span class="stt">in:</span> is thus not entirely whimsical,
but is very open to improvement.  Likewise, there is no <span class="stt">=</span> in <span class="stt">defstruct:</span>, but instead <span class="stt">has:</span>, to emphasize that a structure <span style="font-style: italic">has</span> the following fields.</p></li><li><p><span class="stt">do:</span> could consider using braces rather than parens, if these were enforceable.
(Semi-colons between terms in the <span class="stt">do:</span> will never be enforceable, but will provide a
pleasing touch to traditionalists &ndash; who might, however, accidentally put two commands on
one line and be surprised to find the second one does not execute.)</p></li><li><p>Using the <span class="stt">def</span>- prefix for the definition constructs leaves open <span class="stt">fun:</span> for anonymous functions.</p></li><li><p>The syntax of <span class="stt">fun:</span> feels a bit naked: one needs to really understand expression-ness to understand
(beyond indentation)
where a function ends.  A pair of delimiters wrapping the entire body would reduce this anxiety.</p></li><li><p><span class="stt">if:</span> does not need any intermediate keywords at all.  In their absence, however, the programmer would
 be reduced to counting the number of preceding expressions and checking parity to know what they were
 looking at.  Intermediate keywords improve both readability and error-reporting (which are probably linked).</p></li></ul></div></p><h5>4.2.3<tt>&nbsp;</tt><a name="(part._.Handling_.Variterm_.Constructs)"></a>Handling Variterm Constructs</h5><p>Some constructs, such as Racket&rsquo;s <span class="stt">cond</span>, <span class="stt">begin</span>, and <span class="stt">when</span>, contain a variable number of body terms.  This makes it challenging to keep their parsing simple and predictable.  I see two broad ways to handle these: what I call <span class="stt">if:</span>-style and <span class="stt">do:</span>-style.  <span class="stt">do:</span>-style is the lazy option: it uses a delimiter pair (specifically, brackets) and brutally dumps the terms between the delimiters.  <span class="stt">if:</span>-style instead uses carefully-designed intermediate keywords as guideposts to the parser.  The brutality of the <span class="stt">do:</span>-style could be reduced by the use of intermediate keywords, but at that point the delimiters wouldn&rsquo;t be necessary any longer.  (They wouldn&rsquo;t be <span style="font-style: italic">necessary</span>, but they may still be helpful, as the number or size of sub-terms grows large.)  Constructs like <span class="stt">when:</span>, which frequently have multiple, imperative body terms, would be better served by the brutalist style, because otherwise programmers would have to write an additional <span class="stt">do:</span> inside the single body term most of the time.</p><h5>4.2.4<tt>&nbsp;</tt><a name="(part._.Avoiding_.Closing_.Delimiters)"></a>Avoiding Closing Delimiters</h5><p>Nothing in the language design precludes closing delimiters.  However, because parsing is always predictable, there is no <span style="font-style: italic">need</span> for them, either.  Offering them could improve error reporting.</p><h5>4.2.5<tt>&nbsp;</tt><a name="(part._.Not_.Specifying_the_.Indentation_of_.Parenthetical_.Pairs)"></a>Not Specifying the Indentation of Parenthetical Pairs</h5><p>P4P currently does not enforce any indentation convention on parenthetical constructs.  Indeed, I wonder to what extent the Scheme antipathy towards putting closing delimiters on separate lines is because of just how many darn ones there are.  If the only closing delimiters are for constructs that need them (such as <span class="stt">do:</span>), it may even &ndash; gasp &ndash; be <span style="font-style: italic">good style</span> to put them on distinct lines, lining up with the opening keyword.</p><h3>5<tt>&nbsp;</tt><a name="(part._.Indentation___.Rules_)"></a>Indentation...Rules!</h3><p>There are only three indentation rules in P4P: <span class="Smaller">SLSC</span>, and <span class="Smaller">SLGC</span>, and <span class="Smaller">SLGEC</span>.  These stand for <span style="font-style: italic">same-line-same-column</span>, <span style="font-style: italic">same-line-greater-column</span>, and <span style="font-style: italic">same-line-greater-equal-column</span>, respectively.  As you read more about these, you may find them insufficiently restrictive.  Keep in mind that indentation rules are contravariant to language size: sub-languages (such as teaching languages) can enforce many more restrictions on lines and columns.</p><p><div class="SIntrapara"><span class="Smaller">SLGC</span> is the fundamental rule of indentation.  As the name suggests, each sub-term must be either on the same line or (if not on the same line) indented to the right from the head term.  The same-line part enables one-liners, though a teaching language might want to prevent excessively long lines &ndash; for instance, by disallowing the same-line part entirely for some constructs.  In fact, the syntactic effect of <span class="Smaller">SLGC</span> is a little subtle: it means the first few arguments can be on the same line as the operator, while all subsequent ones must be indented, like so:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">+(1, 2,</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">dbl(4),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">dbl(dbl(8)))</span></span></p></td></tr></table></div></p><p><span class="Smaller">SLSC</span> is used more rarely, when we want rigid alignment.  Currently, only <span class="stt">if:</span> uses <span class="Smaller">SLSC</span> for its internal keywords (<span class="stt">elif:</span> and <span class="stt">else:</span>).</p><p><div class="SIntrapara">Finally, <span class="Smaller">SLGEC</span> was added for internal keywords that are not the same width as the main keyword.  One might want to write
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">let: x = 3</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;</span><span class="stt">in: +(x, x)</span></span></p></td></tr></table></div><div class="SIntrapara">to line up the colons, or instead
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">let: x = 3</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">in: +(x, x)</span></span></p></td></tr></table></div><div class="SIntrapara">to keep the code from drifting rightward.  (Of course, the programmer can put the <span class="stt">in:</span> on the previous line, too.)  P4P sees no need to choose between these two indentation styles.  Hence <span class="Smaller">SLGEC</span> permits an indentation of zero or more.</div></p><p><div class="SIntrapara">The decision to use <span class="Smaller">SLGC</span> and not <span class="Smaller">SLSC</span> for, say, argument lists may be surprising.  It suggests the following is considered acceptable:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: f (x) =</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">+(dbl(dbl(x)),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">dbl(x))</span></span></p></td></tr></table></div><div class="SIntrapara">This looks odd, but consider instead this case:
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">defvar: mfib =</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">memoize(</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">fun: (n) in:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">...</span></span></p></td></tr></table></div><div class="SIntrapara">In other words, when a function has &ldquo;fat&rdquo; parameters, we don&rsquo;t want to force rightward drift (or effectively impose shorter function names).  Thus, we only expect arguments be farther to the right than the beginning of the function name, not necessarily &ldquo;within&rdquo; the argument&rsquo;s parentheses.</div></p><p><div class="SIntrapara">In practice, it has proven more pleasant to impose a slightly stricter rule for <span class="Smaller">SLGC</span>: to demand an indentation of at least two spaces, not just one.  Two spaces increases readability (Python programmers often use four); it also means egregious
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: f (x) =</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">+(dbl(dbl(x)),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">dbl(x))</span></span></p></td></tr></table></div><div class="SIntrapara">is illegal, and must instead be at least
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">deffun: f (x) =</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">+(dbl(dbl(x)),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">dbl(x))</span></span></p></td></tr></table></div></p><p><div class="SIntrapara">One consequence of the relative laxness of <span class="Smaller">SLGC</span> &ndash; which a teaching language might want to tighten &ndash; is that P4P doesn&rsquo;t enforce that the immediate sub-expressions in an <span class="stt">if:</span> are at the same level.  Thus, both
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if: test1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">elif: test2</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e2</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">else:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e3</span></span></p></td></tr></table></div><div class="SIntrapara">and
</div><div class="SIntrapara"><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if: test1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e1</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">elif: test2</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e2</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">else:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e3</span></span></p></td></tr></table></div><div class="SIntrapara">are legal, as different collections of people may prefer different coding styles.</div></p><h3>6<tt>&nbsp;</tt><a name="(part._.On_.Groves_and_.Brooks__or__.Trees_and_.Streams_)"></a>On Groves and Brooks (or, Trees and Streams)</h3><p>The Lisp bicameral syntax tradition is based on processing <span style="font-style: italic">trees</span>.  The parentheses chunk tokens into well-formed trees, and the parser chunks these into valid trees.  It&rsquo;s parentheses &ndash; and thus trees &ndash; all the way down.</p><p>Except, it isn&rsquo;t.  A file is not a tree.  Thus, sitting outside every Lisp parser of popular imagination is another parser that operates, instead, on <span style="font-style: italic">streams</span>.</p><p>Happily, Racket provides a middle-ground: files without explicit wrappers can be written in <span class="stt">#lang</span>, but <span class="stt">#%module-begin</span> turns this back into a tree.</p><p>This mapping enables the P4P parser to leverage the Racket macro system to bootstrap.  P4P removes tokens sequentially, using a slack term in every pattern to match the rest of the stream; each construct&rsquo;s parser returns a tree and what remains of the stream after it is done processing.</p><p>Oh, and commas.  Of course, Racket converts commas to <span class="stt">unquote</span>.  In Racket, the <span class="stt">unquote</span> is followed by a single tree; in P4P, it is followed by an arbitrary <span style="font-style: italic">undelimited</span> expression.  So P4P lets Racket turn commas into <span class="stt">unquote</span>s, and then simply returns the subsequent tree (in Racket&rsquo;s terms) to the front of the token stream, for continued P4P parsing.</p><h3>7<tt>&nbsp;</tt><a name="(part._.Error_.Reporting)"></a>Error Reporting</h3><p>I have invested (almost) no time into error messages, yet.</p><p>By being a <span style="font-style: italic">macro</span> over existing Racket, P4P inherits much of Racket&rsquo;s context-sensitive error-reporting.
Naturally, having additional clauses in P4P can improve error checking.  For instance, in the current implementation, <span class="stt">deffun: f "var" = 3</span> and <span class="stt">deffun: f(3) = 3</span> happen to be caught by P4P itself (which highlights the appropriate term), while other errors pass through to Racket, using its error messages and highlighting.  (The expression <span class="stt">3(4)</span> <span style="font-style: italic">ought</span> to demonstrate this, but currently fails on a internal error instead.)</p><p>Because P4P&rsquo;s parsing is done through streams rather than trees, it is unclear how much of Ryan Culpepper&rsquo;s infrastructure for strengthening tree-based patterns to insert error checks will apply here.  It is more likely that something analogous needs to be created for stream processing.  In the best case, of course, Ryan&rsquo;s work will carry over unchanged.  Either way, this will be a fruitful area for further examination.</p><p>Finally, one known problematic case is this: when a comma-separated list fails to have a term between the (intended) penultimate comma and the closing parentheses (e.g., <span class="stt">f(x, y,)</span>).  This is an unfortunate consequence of P4P&rsquo;s attempt to reuse the Racket toolchain, and will need special support.  This is a place where <span class="Smaller">EOPL</span>&rsquo;s sllgen parser has no problems, because it natively implements both scanner and parser.</p><h3>8<tt>&nbsp;</tt><a name="(part._.Syntax_.Extensions)"></a>Syntax Extensions</h3><p>It would be easy to add new constructs such as <span class="stt">or:</span> and <span class="stt">and:</span>, <span class="stt">provide:</span>, <span class="stt">test:</span>, <span class="stt">const:</span> (to distinguish from <span class="stt">defvar:</span>), and so on.</p><p>The current design of P4P also does not preclude the addition of syntactic enhancements such as type declarations, default argument values, and so on.  It is presumably also possible to add support for Racket keywords and reader extensions.</p><p>One particularly curious form of syntactic extension would be to use fully-parenthesized terms in some contexts.  For instance, we might add a <span class="stt">racket:</span> construct that is followed by a fully-parenthesized s-expression.  Because of the nature of P4P&rsquo;s syntax, this can be done without any ambiguity.  One might even, say, decide to use P4P syntax to define macros for <span style="font-style: italic">parenthetical</span> Racket; the P4P versions of <span class="stt">syntax-rules</span> or <span class="stt">syntax-case</span> can exploit P4P&rsquo;s parenthetical sparsity <span style="font-style: italic">except</span> for the patterns themselves, which would be  fully-parenthesized as they would in traditional Racket (and in the source they process).</p><p><div class="SIntrapara">Beyond this, it is in principle possible for developers to create macros for new P4P syntactic constructs.  After all, P4P is already defined using just macros.  However:
</div><div class="SIntrapara"><ul><li><p>The macro definer has to understand the stream-processing pattern,
which is different from traditional tree-shaped macro processing.</p></li><li><p>Even more importantly, the macro writer undertakes to create a construct that does not
introduce syntactic ambiguity &ndash; a property that is guaranteed in Racket, but earned in P4P.
(To be clear, a new Racket macro can be ambiguous: imagine an <span class="stt">infix</span> macro, which
requires precedence rules for disambiguation.  However,
this ambiguity is limited to the inside of the new construct, and cannot affect terms past
the closing parenthesis.  In P4P, the effect may leak past the end of the construct.)</p></li></ul></div><div class="SIntrapara">For these reasons, we will probably need to create a macro-definition facility: a <span class="stt">syntax-rules</span> for streams.  However, that is not enough:
</div><div class="SIntrapara"><ul><li><p>The macro writer needs to check indentation.  This may require a pattern language that is
indentation-sensitive.</p></li><li><p>The output of the macros will, by default, interact with the indentation checking of the
underlying P4P language.  One option is to have the macros respect this, though it will likely
make them too difficult to write (because any loss of source location would leave the underlying
P4P parser unable to perform checks, and hence forced to reject the program).  A second option is to
generate code in a P4P variant that doesn&rsquo;t check indentation.  A third, perhaps best,
solution would be to generate Racket code directly, just as the current P4P does: that is, the
macro system would be an attached-at-the-hip, cooperating twin of P4P, rather than a layer atop it.</p></li></ul></div></p><h3>9<tt>&nbsp;</tt><a name="(part._.Conclusion)"></a>Conclusion</h3><p>Racket has a excellent language design, a great implementation, a superb programming environment, and terrific tools.  Mainstream adoption will, however, always be curtailed by the syntax.  Racket could benefit from liposuction, stomach stapling, or just plain getting off the couch and getting out for a ride, to reduce the layers of parenthetical adipose that &ndash; as this document argues, <span style="font-style: italic">needlessly</span> &ndash; engird it.  P4P is a proposal for how to do this without losing the essential nature of the Lisp syntactic heritage (and, indeed, bringing to the surface the streaming nature that has always been hidden within).</p></div></div><div id="contextindicator">&nbsp;</div></body></html>